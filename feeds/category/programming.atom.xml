<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>*JJ</title><link href="https://jdotjdot.github.io/" rel="alternate"></link><link href="https://jdotjdot.github.io/feeds/category/programming.atom.xml" rel="self"></link><id>https://jdotjdot.github.io/</id><updated>2014-02-11T00:00:00-05:00</updated><entry><title>Day 2:Â Algorithms</title><link href="https://jdotjdot.github.io/2014/02/algorithms/" rel="alternate"></link><updated>2014-02-11T00:00:00-05:00</updated><author><name>JJ</name></author><id>tag:https://jdotjdot.github.io,2014-02-11:2014/02/algorithms/</id><summary type="html">&lt;p&gt;Today, I&amp;#8217;m working on the &lt;a href="https://class.coursera.org/algs4partI-004/lecture"&gt;Princeton Algorithms Coursera Course&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;Main goal overall for today and the next few days is to focus on making sure I know the basics of algorithms, enough to make up for the fact I didn&amp;#8217;t formally study Computer&amp;nbsp;Science.&lt;/p&gt;
&lt;h4&gt;Quick-union&lt;/h4&gt;
&lt;p&gt;I quickly skipped past the first couple of lectures on unions to get to quick-union.  This strategy works with trees of nodes and more efficiently finds if two nodes are connected by finding each node&amp;#8217;s root and determining if they&amp;#8217;re the same root.  To connect nodes, you connect their roots.
Unfortunately, it&amp;#8217;s still a pretty slow strategy, mainly because the trees can get very&amp;nbsp;tall.&lt;/p&gt;
&lt;h4&gt;Weighted&amp;nbsp;quick-union&lt;/h4&gt;
&lt;p&gt;This strategy is a modification of quick-sort so that the trees don&amp;#8217;t get too tall.  Basically, when we&amp;#8217;re connecting a tall tree with a shorter tree, we make sure to put the smaller tree as the child of the bigger tree.  When we&amp;#8217;re adding a node that&amp;#8217;s nested in a different tree, we add that node&amp;#8217;s entire tree as a child of the tree we&amp;#8217;re moving it to.
By adding path compression, we flatten each tree out.  Not quite sure why we&amp;#8217;re doing this; professor says it&amp;#8217;s &amp;#8220;because we&amp;nbsp;can.&amp;#8221;&lt;/p&gt;
&lt;p&gt;Some other topics I glossed over&amp;nbsp;today:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O-time&lt;/li&gt;
&lt;li&gt;Stacks&lt;/li&gt;
&lt;li&gt;This included basic arithmetic expression evaluation, which is basically a small calculator interpreter, which I already did once for a Google Code Jam&amp;nbsp;problem&lt;/li&gt;
&lt;li&gt;Arrays (These I know&amp;nbsp;well)&lt;/li&gt;
&lt;li&gt;Queues (Already wrote a &lt;a href="https://github.com/jdotjdot/CouchQueue"&gt;queue&lt;/a&gt;&amp;#8212;not a pure one, but at least requiring an understanding of&amp;nbsp;theory)&lt;/li&gt;
&lt;li&gt;Iterators&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the rest of the week, I&amp;#8217;m planning to finish what&amp;#8217;s available of the Algorithms course (Elementary Sorts), read chapter 3 of Introduction to Algorithms (data structures), and then try implementing a few data structures in C, finishing by working on some difficult Google Code Jam algorithms problems, before moving onto the next&amp;nbsp;project.&lt;/p&gt;</summary><category term="quick-union"></category><category term="hackerschool"></category></entry></feed>